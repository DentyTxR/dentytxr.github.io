@using System.Text.RegularExpressions;
@using System.Text.Json.Serialization;
@using System.Text.Json;
@inherits SettingsPageBase<PlayerLogToolSettings>
@page "/scpsl/playerlogtool"
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject HttpClient Http
@inject IDialogService DialogService
@inject ISnackbar SnackbarService
@inject IJSRuntime JSRuntime

<PageTitle>PlayerLog Tool</PageTitle>

<MudDialog @bind-Visible="_ruleDialogVisible" Options="dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">Filter Rules</MudText>
    </TitleContent>
    <DialogContent>
        <MudGrid Spacing="4">
            @foreach (var categoryGroup in compiledRules.GroupBy(r => r.Category))
            {
                <MudItem xs="10" sm="7" md="6">
                    <MudPaper Class="pa-3 mud-theme-dark" Square=true>
                        <MudText Typo="Typo.h6" Color="Color.Primary">@categoryGroup.Key</MudText>
                        <MudList T="string">
                            @foreach (var rule in categoryGroup.OrderBy(r => r.Rule.Order))
                            {
                                <MudText Typo="Typo.body2">Display: @rule.DisplayName</MudText>
                                <MudText Typo="Typo.body2">Pattern: @rule.CompiledRegex</MudText>
                                <MudText Typo="Typo.body2">Order: @rule.Rule.Order</MudText>
                                <MudText Typo="Typo.body2">Latest: @rule.Rule.Latest</MudText>
                                <MudDivider Class=" pb-2 mt-2" />
                            }
                        </MudList>
                    </MudPaper>
                </MudItem>
            }
        </MudGrid>
    </DialogContent>
    <DialogActions>
        <MudButton Size="Size.Small" Variant="Variant.Text" OnClick="CloseRuleDialog" Color="Color.Primary">Close</MudButton>
    </DialogActions>
</MudDialog>

<!-- Drag overlay -->
<div id="drag-overlay" class="drag-overlay @(_isDragOver ? "drag-overlay-visible" : "")">
    <div class="drag-overlay-content">
        <MudIcon Icon="@Icons.Material.Filled.CloudUpload" Style="font-size: 4rem;" Color="Color.Primary" />
        <MudText Typo="Typo.h4" Color="Color.Primary">Drop your log file here</MudText>
        <MudText Typo="Typo.body1">Only .log files are accepted</MudText>
    </div>
</div>

<div id="page-content">
    <MudContainer MaxWidth="MaxWidth.Large" Class="mt-8">
        <MudStack AlignItems="AlignItems.Center" Justify="Justify.Center">
            <MudText Typo="Typo.h4">PlayerLog Filter <MudText Inline Typo="Typo.h4" Color="Color.Primary">Beta 0.6</MudText></MudText>
            <MudText Typo="Typo.body1">A simple tool to filter out data from a playerlog.</MudText>
        </MudStack>

        <MudPaper Elevation="1" Class="mt-2 pa-4" Square>
            <MudStack Class="justify-center gap-5 pb-2" Row Breakpoint="Breakpoint.None">
                <MudFileUpload T="IBrowserFile" FilesChanged="HandleManualUpload" Accept=".log">
                    <ActivatorContent>
                        <MudButton Size="Size.Small" Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Upload">
                            Browse...
                        </MudButton>
                    </ActivatorContent>
                </MudFileUpload>
                <MudButton OnClick="UrlDialogPopup" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Upload">
                    Upload via URL
                </MudButton>
                <MudButton OnClick="OpenRuleDialog" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Upload">
                    View rules
                </MudButton>
            </MudStack>

            <MudTabs Elevation="0" Color="Color.Dark" PanelClass="mud-theme-dark" Border="true" Rounded>
                @foreach (var categoryName in compiledRules.Where(c => c.Category != "Errors").Select(c => c.Category).Distinct())
                {
                    var entries = logEntries
                    .Where(e => e.Category.Equals(categoryName, StringComparison.OrdinalIgnoreCase))
                    .OrderBy(e => e.Order);

                    var badgeEntry = entries.FirstOrDefault(e => !string.IsNullOrWhiteSpace(e.BadgeText));
                    <MudTabPanel Text="@categoryName" BadgeData="@(badgeEntry?.BadgeText)" BadgeColor="@(badgeEntry?.BadgeColor ?? Color.Success)">
                        <div class="pt-2 pb-2 pl-3 pr-3" style="min-height:400px; max-height: 600px; overflow-y:auto;">
                            @if (entries.Any())
                            {
                                @foreach (var entry in entries)
                                {
                                    if (entry.DisplayName == "CPU" || entry.DisplayName == "GPU")
                                    {
                                        <MudText Class="pb-2">
                                            <MudText Inline Color="entry.HighlightText"><b>@entry.DisplayName:</b></MudText>
                                            <MudText Inline Color="entry.HighlightText">@entry.Response</MudText>
                                        </MudText>
                                    }
                                    else
                                    {
                                        <MudText Class="pb-2">
                                            <MudText Inline Color="Color.Primary"><b>@entry.DisplayName:</b></MudText> @entry.Response
                                        </MudText>
                                    }
                                }
                            }
                            else
                            {
                                <MudText>No entries for this category</MudText>
                            }
                        </div>
                    </MudTabPanel>
                }            

                @if (categoryLoaded)
                {
                    var errorEntries = logEntries
                    .Where(e => e.Category.Equals("Errors", StringComparison.OrdinalIgnoreCase))
                    .OrderBy(e => e.Order);
                    
                    var errorBadgeEntry = errorEntries.FirstOrDefault(e => !string.IsNullOrWhiteSpace(e.BadgeText));
                    var errorBadge = errorBadgeEntry?.BadgeText ?? (errorEntries.Any() ? "!" : "0");
                    var errorBadgeColor = errorBadgeEntry?.BadgeColor ?? (errorEntries.Any() ? Color.Error : Color.Success);
            
                    <MudTabPanel Text="Errors" BadgeData="@errorBadge" BadgeColor="@errorBadgeColor">
                        <div class="pt-2 pb-2 pl-3 pr-3" style="min-height:400px; max-height: 600px; overflow-y:auto;">
                            @if (errorEntries.Any())
                            {
                                foreach (var entry in errorEntries)
                                {
                                    <MudPaper Class="pa-3 my-2" Elevation="0">
                                        <MudText Typo="Typo.h6" Color="Color.Error">@entry.Response</MudText>
                                        <MudDivider Class="my-1" />
                                        <MudText Typo="Typo.body1" Color="Color.Primary">Solution:</MudText>
                                        <MudText Typo="Typo.subtitle2">@((MarkupString)entry.Solution)</MudText>
                                    </MudPaper>
                                }
                            }
                            else
                            {
                                <MudText>No errors found in this log.</MudText>
                            }
                        </div>
                    </MudTabPanel>

                    <MudTabPanel Text="Raw">
                        <div class="pt-2 pb-2 pl-3 pr-3" style="min-height:400px; max-height: 600px; overflow-y:auto;">
                            @if (!string.IsNullOrEmpty(uploadedFile))
                            {
                                <pre style="white-space: pre-wrap; word-break: break-all;">@uploadedFile</pre>
                            }
                            else
                            {
                                <MudText>No entries for this category</MudText>
                            }
                        </div>
                    </MudTabPanel>
                }
            </MudTabs>
        </MudPaper>
    </MudContainer>
</div>

@code {
    private class LogEntry //clean & found data
    {
        public string Category { get; set; } = "Uncategorized";
        public string DisplayName { get; set; } = string.Empty;
        public string Response { get; set; } = string.Empty;
        public string Solution { get; set; } = string.Empty;
        public int Order { get; set; } = 0;
        public Color HighlightText { get; set; } = Color.Primary;
        public string BadgeText { get; set; } = string.Empty;
        public Color BadgeColor { get; set; } = Color.Default;
    }

    private class CompiledRule //preloaded, for performance
    {
        public string Category { get; set; } = string.Empty;
        public string DisplayName { get; set; } = string.Empty;
        public PlayerLogRule Rule { get; set; } = default!;
        public Regex CompiledRegex { get; set; } = default!;
    }

    public class PassmarkData
    {
        [JsonPropertyName("cpu")]
        public Dictionary<string, int> Cpu { get; set; } = new();
        [JsonPropertyName("gpu")]
        public Dictionary<string, int> Gpu { get; set; } = new();
    }

    public class MinRequirements
    {
        [JsonPropertyName("cpu")]
        public string MinCpu { get; set; } = string.Empty;
        [JsonPropertyName("gpu")]
        public string MinGpu { get; set; } = string.Empty;
    }

    private string uploadedFile = string.Empty;

    private string minCpu = "";
    private string minGpu = "";

    private List<LogEntry> logEntries = new(); //actual cleaned
    private List<CompiledRule> compiledRules = new(); //preload
    private Dictionary<string, Dictionary<string, PlayerLogRule>> rules = new(); //raw
    private Dictionary<string, int> cpuScores = new();
    private Dictionary<string, int> gpuScores = new();

    private string logUrl = "";

    private bool categoryLoaded = false;
    private bool _isDragOver = false;

    private readonly DialogOptions dialogOptions = new() { MaxWidth = MaxWidth.Large };
    private bool _ruleDialogVisible = false;

    private void OpenRuleDialog() => _ruleDialogVisible = true;
    private void CloseRuleDialog() => _ruleDialogVisible = false;
    
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        
        try
        {
            LoadingService.Show("Loading rules...");
            await ShowLoading();

            var playerlogJson = await Http.GetStringAsync("data/playerlogRules.json");

            rules = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, PlayerLogRule>>>(playerlogJson) ?? new();

            compiledRules = rules.SelectMany(category => category.Value.Select(rule => new CompiledRule
            {
                Category = category.Key,
                DisplayName = rule.Key,
                Rule = rule.Value,
                CompiledRegex = new Regex(rule.Value.Pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled)
            })).ToList();

            categoryLoaded = true;
            LoadingService.Show("Loading data...");
            await ShowLoading();
            
            if (PageSettings.EnableHardwareCompare)
            {
                var minReqJson = await Http.GetStringAsync("data/scpslMinHardware.json");
                var passmarkJson = await Http.GetStringAsync("data/passmark-data.json");
                
                LoadingService.Show("Deserializing data...");
                await ShowLoading();
                
                var minResults = JsonSerializer.Deserialize<MinRequirements>(minReqJson) ?? new();
                minCpu = minResults.MinCpu ?? "";
                minGpu = minResults.MinGpu ?? "";
                
                var results = JsonSerializer.Deserialize<PassmarkData>(passmarkJson);
                if (results != null)
                {
                    cpuScores = results.Cpu ?? new Dictionary<string, int>();
                    gpuScores = results.Gpu ?? new Dictionary<string, int>();
                }
                
                LoadingService.Show("Warming up...");
                await ShowLoading();
                
                Utils.CompareHardwareHelper.Prime(cpuScores, gpuScores);
            }
        }
        catch (Exception ex)
        {
            ErrorService.ShowError(ex);
        }
        LoadingService.Hide();
        await ShowLoading();
        
        // Initialize drag and drop
        await InitializeDragAndDrop();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await InitializeDragAndDrop();
        }
    }

    private async Task InitializeDragAndDrop()
    {
        var dotNetRef = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("initializeDragAndDrop", dotNetRef);
    }

    [JSInvokable]
    public async Task HandleFileDrop(string fileName, string base64Content)
    {
        try
        {
            _isDragOver = false;
            StateHasChanged();

            if (!fileName.EndsWith(".log", StringComparison.OrdinalIgnoreCase))
            {
                SnackbarService.Add("Only .log files are accepted", Severity.Warning);
                return;
            }

            LoadingService.Show();
            StateHasChanged();

            var bytes = Convert.FromBase64String(base64Content);
            var content = System.Text.Encoding.UTF8.GetString(bytes);

            ProcessPlayerLogContent(content);
            SnackbarService.Add($"File '{fileName}' processed successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            ErrorService.ShowError(ex);
        }
        finally
        {
            LoadingService.Hide();
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void HandleDragEnter()
    {
        _isDragOver = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void HandleDragLeave()
    {
        _isDragOver = false;
        StateHasChanged();
    }

    private async Task ShowLoading()
    {
        await InvokeAsync(StateHasChanged);
        await Task.Delay(1);
    }

    protected override string SettingsKey => "PlayerLogToolPage";

    protected override List<PageSettingEntry> GetSettingEntries(PlayerLogToolSettings model) => new()
    {
        new PageSettingEntry
        {
            Title = "Hardware Comparison",
            Description = "Should the uploaded hardware be compared to the min requirements of the game? (This is a PERFORMANCE BOOST when off)",
            Editor = @<MudSwitch @bind-Value="model.EnableHardwareCompare" />
        }
    };

    private async Task UrlDialogPopup()
    {
        var parameters = new DialogParameters<Components.InsertUrlDialog>
        {
            { x => x.Content, @<MudAlert Severity="Severity.Warning">Larger files (5MB+) will not upload, This is due to the CORS proxy limit. Larger files will take longer to process.</MudAlert> },
            { x => x.ButtonText, "Upload" }
        };

        var options = new DialogOptions
        {
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.ExtraSmall
        };

        var dialog = await DialogService.ShowAsync<Components.InsertUrlDialog>("URL Upload", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is string url && !string.IsNullOrWhiteSpace(url))
        {
            logUrl = url;
            await HandleUrlUpload();
        }
    }

    private async Task HandleUrlUpload()
    {
        if (string.IsNullOrWhiteSpace(logUrl)) return;

        LoadingService.Show();
        StateHasChanged();

        try
        {
            var content = await Http.GetStringAsync("https://api.codetabs.com/v1/proxy?quest=" + Uri.EscapeDataString(logUrl));
            ProcessPlayerLogContent(content);
        }
        catch (Exception ex)
        {
            ErrorService.ShowError(ex);
        }

        LoadingService.Hide();
        StateHasChanged();
    }

    private async Task HandleManualUpload(IBrowserFile file)
    {
        try
        {
            LoadingService.Show();
            StateHasChanged();

            using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); //10mb
            using var reader = new StreamReader(stream);
            var content = await reader.ReadToEndAsync();

            ProcessPlayerLogContent(content);
            LoadingService.Hide();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            ErrorService.ShowError(ex);
            LoadingService.Hide();
        }
    }

    private void ProcessPlayerLogContent(string content)
    {
        logEntries.Clear();
       
        uploadedFile = content.ToString();
       
        var lines = content.Split('\n', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

        foreach (var rule in compiledRules)
        {
            var matches = lines
                .Select((line, idx) => new { line, idx, match = rule.CompiledRegex.Match(line) })
                .Where(x => x.match.Success)
                .ToList();

            if (matches.Count == 0)
                continue;

            var selectedMatch = rule.Rule.Latest ? matches.Last() : matches.First();
            var data = selectedMatch.match.Groups[1].Value;

            string response = rule.Rule.Response.Replace("${data}", data);

            var entry = new LogEntry
            {
                Category = rule.Category,
                DisplayName = rule.DisplayName,
                Solution = ConvertMarkdownToHtml(rule.Rule.Solution),
                Order = rule.Rule.Order
            };

            switch (rule.DisplayName)
            {
                case "OS":
                    response = response.Replace("${status}", GetOsStatus(data));
                    break;
                case "CPU":
                    if (PageSettings.EnableHardwareCompare)
                    {
                        var status = Utils.CompareHardwareHelper.CompareCpu(data, minCpu, cpuScores);
                        response = response.Replace("${status}", "");

                        if (status.Contains("Below Minimum"))
                            entry.HighlightText = Color.Error;
                        else if (status.Contains("Above Minimum"))
                            entry.HighlightText = Color.Success;
                        else
                            entry.HighlightText = Color.Default;
                    }
                    else
                    {
                        response = response.Replace("${status}", string.Empty);
                    }
                    break;
                case "GPU":
                    if (PageSettings.EnableHardwareCompare)
                    {
                        var status = Utils.CompareHardwareHelper.CompareGpu(data, minGpu, gpuScores);
                        response = response.Replace("${status}", "");

                        if (status.Contains("Below Minimum"))
                            entry.HighlightText = Color.Error;
                        else if (status.Contains("Above Minimum"))
                            entry.HighlightText = Color.Success;
                        else
                            entry.HighlightText = Color.Default;
                    }
                    else
                    {
                        response = response.Replace("${status}", string.Empty);
                    }
                    break;
            }

            if (rule.Category == "Errors")
            {
                entry.HighlightText = Color.Error;
                entry.BadgeText = "!";
                entry.BadgeColor = Color.Error;
            }

            entry.Response = response;

            logEntries.Add(entry);
        }
    }
  
    private static string ConvertMarkdownToHtml(string? markdown)
    {
        if (string.IsNullOrEmpty(markdown))
        return string.Empty;
        
        string html = Regex.Replace(markdown,@"\[(.*?)\]\((.*?)\)","<a href=\"$2\" target=\"_blank\" class=\"highlight-link\">$1</a>");
        
        html = html.Replace("\r\n", "<br />").Replace("\n", "<br />");
        return html;
    }
    
    private string GetOsStatus(string osLine)
    {
        if (osLine.Contains("Windows 10", StringComparison.OrdinalIgnoreCase) || osLine.Contains("Windows 11", StringComparison.OrdinalIgnoreCase))
            return $"[Supported] {osLine}";
        else
            return $"[Unsupported] {osLine}";
    }
}

<style>
    .highlight-link{
        color: var(--mud-palette-primary);
        text-decoration: underline;
    }

    .drag-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 9999;
        align-items: center;
        justify-content: center;
        pointer-events: none;
    }

    .drag-overlay-visible {
        display: flex !important;
    }

    .drag-overlay-content {
        text-align: center;
        padding: 2rem;
        border: 2px dashed var(--mud-palette-primary);
        border-radius: 8px;
        background-color: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
    }
</style>

<script>
    window.initializeDragAndDrop = (dotNetRef) => {
        let dragCounter = 0;

        const handleDragEnter = (e) => {
            e.preventDefault();
            e.stopPropagation();
            dragCounter++;
            
            if (dragCounter === 1) {
                dotNetRef.invokeMethodAsync('HandleDragEnter');
            }
        };

        const handleDragLeave = (e) => {
            e.preventDefault();
            e.stopPropagation();
            dragCounter--;
            
            if (dragCounter === 0) {
                dotNetRef.invokeMethodAsync('HandleDragLeave');
            }
        };

        const handleDragOver = (e) => {
            e.preventDefault();
            e.stopPropagation();
        };

        const handleDrop = (e) => {
            e.preventDefault();
            e.stopPropagation();
            dragCounter = 0;
            
            dotNetRef.invokeMethodAsync('HandleDragLeave');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                
                if (!file.name.toLowerCase().endsWith('.log')) {
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    const base64Content = btoa(event.target.result);
                    dotNetRef.invokeMethodAsync('HandleFileDrop', file.name, base64Content);
                };
                reader.readAsBinaryString(file);
            }
        };

        document.addEventListener('dragenter', handleDragEnter);
        document.addEventListener('dragleave', handleDragLeave);
        document.addEventListener('dragover', handleDragOver);
        document.addEventListener('drop', handleDrop);
        
        window.dragDropCleanup = () => {
            document.removeEventListener('dragenter', handleDragEnter);
            document.removeEventListener('dragleave', handleDragLeave);
            document.removeEventListener('dragover', handleDragOver);
            document.removeEventListener('drop', handleDrop);
        };
    };
</script>