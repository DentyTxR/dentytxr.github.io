@using System.Text.RegularExpressions;
@using System.Text.Json.Serialization;
@using System.Text.Json;
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject HttpClient Http
@inject IDialogService DialogService
@inject ISnackbar SnackbarService

@page "/scpsl/playerlogtool"

<PageTitle>PlayerLog Tool</PageTitle>

<MudOverlay @bind-Visible="isLoading" DarkBackground>
    <MudContainer Style="display:flex; flex-direction:column; align-items:center; justify-content:center;">
        <MudText Typo="Typo.h4">@LoadingMessage</MudText>
        <MudProgressCircular Color="Color.Primary" Size="Size.Large" Indeterminate />
    </MudContainer>
</MudOverlay>

<MudDialog @bind-Visible="_ruleDialogVisible" Options="dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">Filter Rules</MudText>
    </TitleContent>
    <DialogContent>
        <MudGrid Spacing="4">
            @foreach (var categoryGroup in compiledRules.GroupBy(r => r.Category))
            {
                <MudItem xs="10" sm="7" md="6">
                    <MudPaper Class="pa-3 mud-theme-dark" Square=true>
                        <MudText Typo="Typo.h6" Color="Color.Primary">@categoryGroup.Key</MudText>
                        <MudList T="string">
                            @foreach (var rule in categoryGroup.OrderBy(r => r.Rule.Order))
                            {
                                <MudText Typo="Typo.body2">Display: @rule.DisplayName</MudText>
                                <MudText Typo="Typo.body2">Pattern: @rule.CompiledRegex</MudText>
                                <MudText Typo="Typo.body2">Order: @rule.Rule.Order</MudText>
                                <MudText Typo="Typo.body2">Latest: @rule.Rule.Latest</MudText>
                                <MudDivider Class=" pb-2 mt-2" />
                            }
                        </MudList>
                    </MudPaper>
                </MudItem>
            }
        </MudGrid>
    </DialogContent>
    <DialogActions>
        <MudButton Size="Size.Small" Variant="Variant.Text" OnClick="CloseRuleDialog" Color="Color.Primary">Close</MudButton>
    </DialogActions>
</MudDialog>

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-8">
    <MudStack AlignItems="AlignItems.Center" Justify="Justify.Center">
        <MudText Typo="Typo.h4">PlayerLog Filter <MudText Inline Typo="Typo.h4" Color="Color.Primary">Beta 0.5</MudText></MudText>
        <MudText Typo="Typo.body1">A simple tool to filter out data from a playerlog.</MudText>
        <MudText Typo="Typo.body2">UI bad yes i know, i will try to make better :(</MudText>
    </MudStack>

    <MudPaper Elevation="1" Class="mt-2 pa-4" Square>
        <MudStack Class="justify-center gap-5 pb-2" Row Breakpoint="Breakpoint.Sm">
            <MudFileUpload T="IBrowserFile" FilesChanged="HandleManualUpload" Accept="txt">
                <ActivatorContent>
                    <MudButton Size="Size.Small" Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Upload">
                        Browse...
                    </MudButton>
                </ActivatorContent>
            </MudFileUpload>
            <MudButton OnClick="UrlDialogPopup" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Upload">
                Upload via URL
            </MudButton>
            <MudButton OnClick="OpenRuleDialog" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Upload">
                View rules
            </MudButton>
        </MudStack>

        <MudTabs Elevation="3" Color="Color.Dark" PanelClass="mud-theme-dark" Border="true" Outlined="true" ApplyEffectsToContainer="true">
            @foreach (var categoryGroup in compiledRules.GroupBy(r => r.Category))
            {
                var categoryName = categoryGroup.Key;

                var entriesInCategory = logEntries
                .Where(entry => entry.Category.Equals(categoryName, StringComparison.OrdinalIgnoreCase))
                .OrderBy(entry => entry.Order)
                .ToList();

                var entriesWithBadges = entriesInCategory
                .Where(entry => !string.IsNullOrWhiteSpace(entry.BadgeText))
                .ToList();

                bool forceShowBadge = categoryName.Equals("Errors", StringComparison.OrdinalIgnoreCase);

                string? badgeData = null;
                Color badgeColor = Color.Success;

                if (entriesWithBadges.Any())
                {
                    var firstBadge = entriesWithBadges.First();
                    badgeData = firstBadge.BadgeText;
                    badgeColor = firstBadge.BadgeColor;
                }
                else if (forceShowBadge)
                {
                    badgeData = "0";
                    badgeColor = Color.Success;
                }

                <MudTabPanel Text="@categoryName" BadgeData="@badgeData" BadgeColor="@badgeColor">
                    <div class="pt-2 pb-2 pl-3 pr-3" style="min-height:300px; max-height: 500px; overflow-y:auto;">
                        <MudText Typo="Typo.h6" Color="Color.Primary">@categoryName</MudText>
                        @if (entriesInCategory.Any())
                        {
                            foreach (var entry in entriesInCategory)
                            {
                                <MudText Class="pb-2"><MudText Inline Color="entry.HighlightText"><b>@entry.DisplayName:</b></MudText> @entry.Response</MudText>
                            }
                        }
                        else
                        {
                            <MudText>No entries for this category</MudText>
                        }
                    </div>
                </MudTabPanel>
            }
        </MudTabs>
    </MudPaper>
</MudContainer>


@code {
    private class LogEntry //clean & found data
    {
        public string DisplayName { get; set; } = string.Empty;
        public string Response { get; set; } = string.Empty;
        public string Category { get; set; } = "Uncategorized";
        public int Order { get; set; } = 0;
        public Color HighlightText { get; set; } = Color.Primary;
        public string BadgeText { get; set; } = string.Empty;
        public Color BadgeColor { get; set; } = Color.Default;
    }

    private class CompiledRule //preloaded, for performance
    {
        public string Category { get; set; } = string.Empty;
        public string DisplayName { get; set; } = string.Empty;
        public PlayerLogRuleModel Rule { get; set; } = default!;
        public Regex CompiledRegex { get; set; } = default!;
    }

    public class PassmarkData
    {
        [JsonPropertyName("cpu")]
        public Dictionary<string, int> Cpu { get; set; } = new();
        [JsonPropertyName("gpu")]
        public Dictionary<string, int> Gpu { get; set; } = new();
    }

    public class MinRequirements
    {
        [JsonPropertyName("cpu")]
        public string MinCpu { get; set; } = string.Empty;
        [JsonPropertyName("gpu")]
        public string MinGpu { get; set; } = string.Empty;
    }

    private string minCpu = "";
    private string minGpu = "";

    private List<LogEntry> logEntries = new(); //actual cleaned
    private List<CompiledRule> compiledRules = new(); //preload
    private Dictionary<string, Dictionary<string, PlayerLogRuleModel>> rules = new(); //raw
    private Dictionary<string, int> cpuScores = new();
    private Dictionary<string, int> gpuScores = new();

    private string logUrl = "";

    private bool isLoading = false;
    private string LoadingMessage = "Loading...";

    private readonly DialogOptions dialogOptions = new() { MaxWidth = MaxWidth.Large };
    private bool _ruleDialogVisible = false;

    private void OpenRuleDialog() => _ruleDialogVisible = true;
    private void CloseRuleDialog() => _ruleDialogVisible = false;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            isLoading = true;
            LoadingMessage = "Loading rules...";
            await ShowLoading();

            var playerlogJson = await Http.GetStringAsync("data/playerlogRules.json");

            rules = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, PlayerLogRuleModel>>>(playerlogJson) ?? new();

            compiledRules = rules.SelectMany(category => category.Value.Select(rule => new CompiledRule
            {
                Category = category.Key,
                DisplayName = rule.Key,
                Rule = rule.Value,
                CompiledRegex = new Regex(rule.Value.Pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled)
            })).ToList();

            LoadingMessage = "Loading data...";
            await ShowLoading();

            var minReqJson = await Http.GetStringAsync("data/scpslMinHardware.json");
            var passmarkJson = await Http.GetStringAsync("data/passmark-data.json");

            LoadingMessage = "Deserializing data...";
            await ShowLoading();

            var minResults = JsonSerializer.Deserialize<MinRequirements>(minReqJson) ?? new();
            minCpu = minResults.MinCpu ?? "";
            minGpu = minResults.MinGpu ?? "";

            var results = JsonSerializer.Deserialize<PassmarkData>(passmarkJson);
            if (results != null)
            {
                cpuScores = results.Cpu ?? new Dictionary<string, int>();
                gpuScores = results.Gpu ?? new Dictionary<string, int>();
            }

            LoadingMessage = "Warming up...";
            await ShowLoading();

            Utils.CompareHardwareHelper.Prime(cpuScores, gpuScores);
        }
        catch (Exception ex)
        {
            ErrorService.ShowError(ex);
        }
        isLoading = false;

        LoadingMessage = "Loading...";
        await ShowLoading();
    }

    private async Task ShowLoading()
    {
        await InvokeAsync(StateHasChanged);
        await Task.Delay(1);
    }

    private async Task UrlDialogPopup()
    {
        var parameters = new DialogParameters<Components.InsertUrlDialog>
        {
            { x => x.Content, @<MudAlert Severity="Severity.Warning">Larger files (5MB+) will not upload, This is due to the CORS proxy limit. Larger files will take longer to process.</MudAlert> },
            { x => x.ButtonText, "Upload" }
        };

        var options = new DialogOptions
        {
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.ExtraSmall
        };

        var dialog = await DialogService.ShowAsync<Components.InsertUrlDialog>("URL Upload", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is string url && !string.IsNullOrWhiteSpace(url))
        {
            logUrl = url;
            await HandleUrlUpload();
        }
    }

    private async Task HandleUrlUpload()
    {
        if (string.IsNullOrWhiteSpace(logUrl)) return;

        isLoading = true;
        StateHasChanged();

        try
        {
            var content = await Http.GetStringAsync("https://api.codetabs.com/v1/proxy?quest=" + Uri.EscapeDataString(logUrl));
            ProcessPlayerLogContent(content);
        }
        catch (Exception ex)
        {
            ErrorService.ShowError(ex);
        }

        isLoading = false;
        StateHasChanged();
    }

    private async Task HandleManualUpload(IBrowserFile file)
    {
        try
        {
            isLoading = true;
            StateHasChanged();

            using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); //10mb
            using var reader = new StreamReader(stream);
            var content = await reader.ReadToEndAsync();

            ProcessPlayerLogContent(content);
            isLoading = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            ErrorService.ShowError(ex);
            isLoading = false;
        }
    }

    private void ProcessPlayerLogContent(string content)
    {
        logEntries.Clear();
        var lines = content.Split('\n', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

        foreach (var rule in compiledRules)
        {
            var matches = lines
                .Select((line, idx) => new { line, idx, match = rule.CompiledRegex.Match(line) })
                .Where(x => x.match.Success)
                .ToList();

            if (matches.Count == 0)
                continue;

            var selectedMatch = rule.Rule.Latest ? matches.Last() : matches.First();
            var data = selectedMatch.match.Groups[1].Value;

            string response = rule.Rule.Response.Replace("${data}", data);

            var entry = new LogEntry
            {
                DisplayName = rule.DisplayName,
                Category = rule.Category,
                Order = rule.Rule.Order
            };

            if (rule.DisplayName == "OS")
                response = response.Replace("${status}", GetOsStatus(data));
            else if (rule.DisplayName == "CPU")
            {
                response = response.Replace("${status}", Utils.CompareHardwareHelper.CompareCpu(data, minCpu, cpuScores));
                if (response.Contains("Below Minimum")) //kinda scuffed (like everything) might redo later
                {
                    entry.HighlightText = Color.Error;
                    entry.BadgeText = "!";
                    entry.BadgeColor = Color.Error;
                }
            }
            else if (rule.DisplayName == "GPU")
            {
                response = response.Replace("${status}", Utils.CompareHardwareHelper.CompareGpu(data, minGpu, gpuScores));
                if (response.Contains("Below Minimum"))
                {
                    entry.HighlightText = Color.Error;
                    entry.BadgeText = "!";
                    entry.BadgeColor = Color.Error;
                }
            }

            if (rule.Category == "Errors")
            {
                entry.HighlightText = Color.Error;
                entry.BadgeText = "!";
                entry.BadgeColor = Color.Error;
            }

            entry.Response = response;

            logEntries.Add(entry);
        }
    }

    //hardcode hell below (soon, maybe)
    private string GetOsStatus(string osLine)
    {
        if (osLine.Contains("Windows 10", StringComparison.OrdinalIgnoreCase) || osLine.Contains("Windows 11", StringComparison.OrdinalIgnoreCase))
            return $"[Supported] {osLine}";
        else
            return $"[Unsupported] {osLine}";
    }
}